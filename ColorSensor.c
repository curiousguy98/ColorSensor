
#include	"LPCREG.H"

#define uchar unsigned char
#define uint  unsigned int

/*************	用户系统配置	**************/

#define MAIN_Fosc		18432000L	//定义主时钟, 模拟串口和和延时会自动适应。5~35MHZ

//=================颜色传感模块连接=====================
/*-----------------------------------------------------
|EO-----GND
|S0-----VCC | S2-----P1.0 | OUT-------P3.5 
|S1-----VCC | S3-----P1.1 | 
---------------------------------------------------*/
sbit    tcs230_s2=P1^0;//TCS230 S2接单片机P1.0
sbit    tcs230_s3=P1^1;//TCS230 S3接单片机P1.1
sbit    tcs230_en=P3^0; //TCS230 EN(E0)接GND

void    DelayMs(uint Ms);//1MS基准延时程序
void    baipingheng();//白平衡子程序
void    celiang();//实际颜色程序
uint    ryz,gyz,byz;//分别定义红色因子 绿色因子 蓝色因子
uint    rb,gb,bb;//RGB值

/************* 本地变量声明 **************/
sbit	P_TXD1 = P3^1;
/************* 本地函数声明 **************/
void	Tx1Send(uchar dat);
void	PrintString(unsigned char code *puts);

/*====================================================================
设定延时时间:x*1ms
====================================================================*/
void DelayMs(uint Ms)
{
	uint i,TempCyc;
	for(i=0;i<Ms;i++)
	{
		TempCyc = 250;
		while(TempCyc--);
	}
}

main()   
{   
	AUXR &= 0x3F;		//定时器时钟12T模式
	TMOD=0x51;//设定T0以工作方式1定时10毫秒
	TMOD &= 0xF0;		//设置定时器模式
	TMOD |= 0x01; //使用定时器T0的模式1    
	TR0 = 0; //定时器T0关闭   
	TR1 = 0;		//定时器关闭
	EA = 1; //开启总中断   

	PrintString("****** START ******\r\n");	

	baipingheng();//上电时先白平衡一次
	while(1)
	{
		celiang();//颜色测试

		DelayMs(250);//每隔0.25秒测试一次颜色
	}
} 
//******************************************************
//白平衡子程序
void   celiang()
{
	//*********求R值************************************
	TR0=0;
	TF0=0;   
	TH0=(65536-15360)/256;
	TL0=(65536-15360)%256;
	TH1=0;
	TL1=0;
	tcs230_s2=0;
	tcs230_s3=0;//选择红色滤光器
	tcs230_en=0;
	TR0=1;//10毫秒开始计时
	TR1=1;//开始计数
	while(TF0==0);//等待定时器溢出
	TF0=0;//清楚定时器0溢出标志
	TR0=0;//关闭定时0
	TR1=0;
	rb=(unsigned long)(TH1*256+TL1)*255/ryz;
	if(rb>255)rb=255;//判断RGB值是否合法
	//***********求B值**************************************
	TR0=0;
	TF0=0;
	TH0=(65536-15360)/256;
	TL0=(65536-15360)%256;
	TH1=0;
	TL1=0;
	tcs230_s2=0;
	tcs230_s3=1;//选择蓝色滤光器
	TR0=1;//10毫秒开始计时
	TR1=1;//开始计数
	while(TF0==0);//等待定时器溢出
	TF0=0;//清楚定时器0溢出标志
	TR0=0;//关闭定时0
	TR1=0;
	bb=(unsigned long)(TH1*256+TL1)*255/byz;
	if(bb>255)bb=255;//判断RGB值是否合法     
	//***********求G值**************************************   
	TR0=0;
	TF0=0;
	TH0=(65536-15360)/256;
	TL0=(65536-15360)%256;
	TH1=0;
	TL1=0;
	tcs230_s2=1;
	tcs230_s3=1;//选择绿色滤光器
	TR0=1;//10毫秒开始计时
	TR1=1;//开始计数
	while(TF0==0);//等待定时器溢出
	TF0=0;//清楚定时器0溢出标志
	TR0=0;//关闭定时0
	TR1=0;
	tcs230_en=1;
	gb=(unsigned long)(TH1*256+TL1)*255/gyz;
	if(gb>255)gb=255;//判断RGB值是否合法  


	Tx1Send('R');
	Tx1Send(rb/256);
	Tx1Send(rb%256);
	Tx1Send('G');
	Tx1Send(gb/256);
	Tx1Send(gb%256);
	Tx1Send('B');
	Tx1Send(bb/256);
	Tx1Send(bb%256);
	Tx1Send(' ');
	Tx1Send('\r');
	Tx1Send('\n');

}
//******************************************************
//白平衡子程序
void    baipingheng()
{
	//**************求取红色因子***********************
	TR0=0;
	TF0=0;   
	TH0=(65536-15360)/256;
	TL0=(65536-15360)%256;
	TH1=0;
	TL1=0;
	tcs230_s2=0;
	tcs230_s3=0;//选择红色滤光器
	tcs230_en=0;
	TR0=1;//10毫秒开始计时
	TR1=1;//开始计数
	while(TF0==0);//等待定时器溢出
	TF0=0;//清楚定时器0溢出标志
	TR0=0;//关闭定时0
	TR1=0;
	ryz=TH1*256+TL1;//其实这里的比例因子应该为255/(TH1*256+TL1)
	//**************求取蓝色因子***********************
	TR0=0;
	TF0=0;   
	TH0=(65536-15360)/256;
	TL0=(65536-15360)%256;
	TH1=0;
	TL1=0;
	tcs230_s2=0;
	tcs230_s3=1;//选择蓝色滤光器
	TR0=1;//10毫秒开始计时
	TR1=1;//开始计数
	while(TF0==0);//等待定时器溢出
	TF0=0;//清楚定时器0溢出标志
	TR0=0;//关闭定时0
	TR1=0;
	byz=TH1*256+TL1;//其实这里的比例因子应该为255/(TH1*256+TL1)
	//**************求绿红色因子***********************
	TR0=0;
	TF0=0;   
	TH0=(65536-15360)/256;
	TL0=(65536-15360)%256;
	TH1=0;
	TL1=0;
	tcs230_s2=1;
	tcs230_s3=1;//选择绿色滤光器
	TR0=1;//10毫秒开始计时
	TR1=1;//开始计数
	while(TF0==0);//等待定时器溢出
	TF0=0;//清楚定时器0溢出标志
	TR0=0;//关闭定时0
	TR1=0;
	tcs230_en=1;
	gyz=TH1*256+TL1;//其实这里的比例因子应该为255/(TH1*256+TL1)

	Tx1Send('R');
	Tx1Send(ryz/256);
	Tx1Send(ryz%256);
	Tx1Send('G');
	Tx1Send(gyz/256);
	Tx1Send(gyz%256);
	Tx1Send('B');
	Tx1Send(byz/256);
	Tx1Send(byz%256);


	Tx1Send(' ');
	Tx1Send('\r');
	Tx1Send('\n');

}


/********************** 模拟串口相关函数************************/

void	BitTime(void)	//位时间函数
{
	uint i;
	i = ((MAIN_Fosc / 100) * 8) / 140000L - 1;		//根据主时钟来计算位时间 104为9600，8为115200
	while(--i);
}

//模拟串口发送
void	Tx1Send(uchar dat)		//9600，N，8，1		发送一个字节
{
	uchar	i;
	EA = 0;
	P_TXD1 = 0;
	BitTime();
	for(i=0; i<8; i++)
	{
		if(dat & 1)		P_TXD1 = 1;
		else			P_TXD1 = 0;
		dat >>= 1;
		BitTime();
	}
	P_TXD1 = 1;
	EA = 1;
	BitTime();
	BitTime();
}

void PrintString(unsigned char code *puts)		//发送一串字符串
{
	for (; *puts != 0;	puts++)  Tx1Send(*puts); 	//遇到停止符0结束
}
